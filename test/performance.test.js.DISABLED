// ------------------------------------------------------------------------------
// performance.test.js
// Performance and load testing for Game Thumbs API
// Tests concurrent requests, response times, and system behavior under load
// ------------------------------------------------------------------------------

const http = require('http');
const fs = require('fs');
const path = require('path');

// Configuration
const PORT = 3008; // Different port from other tests
const BASE_URL = `http://localhost:${PORT}`;
const OUTPUT_DIR = path.join(__dirname, 'output');
const RESULTS_FILE = path.join(OUTPUT_DIR, 'performance-results.json');
const TIMEOUT = 30000; // Longer timeout for load tests

// Test results tracking
const results = {
    suiteName: 'Performance Tests',
    timestamp: new Date().toISOString(),
    totalTests: 0,
    passed: 0,
    failed: 0,
    tests: [],
    performanceMetrics: {
        averageResponseTime: 0,
        medianResponseTime: 0,
        p95ResponseTime: 0,
        p99ResponseTime: 0,
        maxResponseTime: 0,
        minResponseTime: Infinity
    }
};

// Performance test configurations
const PERF_CONFIGS = {
    sequential: {
        name: 'Sequential Requests',
        requests: 20,
        concurrent: 1
    },
    lightLoad: {
        name: 'Light Concurrent Load',
        requests: 50,
        concurrent: 5
    },
    mediumLoad: {
        name: 'Medium Concurrent Load',
        requests: 100,
        concurrent: 10
    },
    heavyLoad: {
        name: 'Heavy Concurrent Load',
        requests: 200,
        concurrent: 20
    }
};

// Endpoints to test for performance
const TEST_ENDPOINTS = [
    '/nfl/chiefs/logo',
    '/nba/lakers/thumb',
    '/mlb/yankees/logo',
    '/nhl/bruins/thumb',
    '/epl/manchester-united/logo'
];

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// ------------------------------------------------------------------------------
// Helper Functions
// ------------------------------------------------------------------------------

function makeRequest(url, timeout = TIMEOUT) {
    return new Promise((resolve, reject) => {
        const startTime = Date.now();
        const timeoutId = setTimeout(() => {
            reject(new Error(`Request timeout after ${timeout}ms`));
        }, timeout);

        http.get(url, (res) => {
            clearTimeout(timeoutId);
            
            const chunks = [];
            res.on('data', chunk => chunks.push(chunk));
            res.on('end', () => {
                const duration = Date.now() - startTime;
                const buffer = Buffer.concat(chunks);
                resolve({
                    statusCode: res.statusCode,
                    contentType: res.headers['content-type'],
                    body: buffer,
                    duration: duration
                });
            });
        }).on('error', (err) => {
            clearTimeout(timeoutId);
            reject(err);
        });
    });
}

function waitForServer(maxAttempts = 30, delayMs = 1000) {
    return new Promise((resolve, reject) => {
        let attempts = 0;

        const checkServer = () => {
            attempts++;
            http.get(`${BASE_URL}/health`, (res) => {
                if (res.statusCode === 200) {
                    resolve();
                } else if (attempts < maxAttempts) {
                    setTimeout(checkServer, delayMs);
                } else {
                    reject(new Error('Server failed to start'));
                }
            }).on('error', () => {
                if (attempts < maxAttempts) {
                    setTimeout(checkServer, delayMs);
                } else {
                    reject(new Error('Server failed to start'));
                }
            });
        };

        checkServer();
    });
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function saveResults() {
    const json = JSON.stringify(results, null, 2);
    fs.writeFileSync(RESULTS_FILE, json);
    console.log(`\nðŸ“„ Results saved to: ${RESULTS_FILE}`);
}

function calculatePercentile(sortedArray, percentile) {
    const index = Math.ceil((percentile / 100) * sortedArray.length) - 1;
    return sortedArray[index];
}

function updatePerformanceMetrics(responseTimes) {
    const sorted = responseTimes.slice().sort((a, b) => a - b);
    const sum = sorted.reduce((a, b) => a + b, 0);
    
    results.performanceMetrics.averageResponseTime = Math.round(sum / sorted.length);
    results.performanceMetrics.medianResponseTime = Math.round(calculatePercentile(sorted, 50));
    results.performanceMetrics.p95ResponseTime = Math.round(calculatePercentile(sorted, 95));
    results.performanceMetrics.p99ResponseTime = Math.round(calculatePercentile(sorted, 99));
    results.performanceMetrics.maxResponseTime = sorted[sorted.length - 1];
    results.performanceMetrics.minResponseTime = sorted[0];
}

// ------------------------------------------------------------------------------
// Test Functions
// ------------------------------------------------------------------------------

async function testSequentialRequests(config) {
    const testResult = {
        name: config.name,
        passed: false,
        error: null,
        duration: 0,
        requestCount: config.requests,
        successCount: 0,
        failureCount: 0,
        responseTimes: [],
        avgResponseTime: 0,
        throughput: 0
    };

    const startTime = Date.now();
    const responseTimes = [];

    try {
        console.log(`   Making ${config.requests} sequential requests...`);
        
        for (let i = 0; i < config.requests; i++) {
            const endpoint = TEST_ENDPOINTS[i % TEST_ENDPOINTS.length];
            
            try {
                const response = await makeRequest(`${BASE_URL}${endpoint}`);
                
                if (response.statusCode === 200) {
                    testResult.successCount++;
                    responseTimes.push(response.duration);
                } else {
                    testResult.failureCount++;
                }
                
                if ((i + 1) % 10 === 0) {
                    process.stdout.write(`\r   Progress: ${i + 1}/${config.requests}`);
                }
            } catch (error) {
                testResult.failureCount++;
            }
        }
        
        console.log(''); // New line after progress
        
        testResult.duration = Date.now() - startTime;
        testResult.responseTimes = responseTimes;
        testResult.avgResponseTime = Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length);
        testResult.throughput = ((testResult.successCount / testResult.duration) * 1000).toFixed(2);
        
        if (testResult.successCount >= config.requests * 0.95) { // 95% success rate required
            testResult.passed = true;
        } else {
            throw new Error(`Only ${testResult.successCount}/${config.requests} requests succeeded`);
        }
    } catch (error) {
        testResult.error = error.message;
        testResult.duration = Date.now() - startTime;
    }

    return testResult;
}

async function testConcurrentRequests(config) {
    const testResult = {
        name: config.name,
        passed: false,
        error: null,
        duration: 0,
        requestCount: config.requests,
        concurrency: config.concurrent,
        successCount: 0,
        failureCount: 0,
        responseTimes: [],
        avgResponseTime: 0,
        throughput: 0
    };

    const startTime = Date.now();
    const responseTimes = [];

    try {
        console.log(`   Making ${config.requests} requests with concurrency ${config.concurrent}...`);
        
        const chunks = [];
        for (let i = 0; i < config.requests; i += config.concurrent) {
            chunks.push(Math.min(config.concurrent, config.requests - i));
        }

        for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
            const chunkSize = chunks[chunkIndex];
            const promises = [];
            
            for (let i = 0; i < chunkSize; i++) {
                const endpointIndex = (chunkIndex * config.concurrent + i) % TEST_ENDPOINTS.length;
                const endpoint = TEST_ENDPOINTS[endpointIndex];
                
                promises.push(
                    makeRequest(`${BASE_URL}${endpoint}`)
                        .then(response => {
                            if (response.statusCode === 200) {
                                responseTimes.push(response.duration);
                                return { success: true, duration: response.duration };
                            } else {
                                return { success: false };
                            }
                        })
                        .catch(() => ({ success: false }))
                );
            }
            
            const batchResults = await Promise.all(promises);
            batchResults.forEach(result => {
                if (result.success) {
                    testResult.successCount++;
                } else {
                    testResult.failureCount++;
                }
            });
            
            const completed = (chunkIndex + 1) * config.concurrent;
            process.stdout.write(`\r   Progress: ${Math.min(completed, config.requests)}/${config.requests}`);
            
            // Small delay between batches to avoid overwhelming the server
            await sleep(10);
        }
        
        console.log(''); // New line after progress
        
        testResult.duration = Date.now() - startTime;
        testResult.responseTimes = responseTimes;
        testResult.avgResponseTime = Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length);
        testResult.throughput = ((testResult.successCount / testResult.duration) * 1000).toFixed(2);
        
        if (testResult.successCount >= config.requests * 0.90) { // 90% success rate for concurrent tests
            testResult.passed = true;
        } else {
            throw new Error(`Only ${testResult.successCount}/${config.requests} requests succeeded`);
        }
    } catch (error) {
        testResult.error = error.message;
        testResult.duration = Date.now() - startTime;
    }

    return testResult;
}

async function testResponseTimeConsistency() {
    const testResult = {
        name: 'Response Time Consistency',
        passed: false,
        error: null,
        duration: 0,
        sampleSize: 30,
        responseTimes: [],
        avgResponseTime: 0,
        stdDeviation: 0,
        variability: 0
    };

    const startTime = Date.now();
    const responseTimes = [];

    try {
        console.log(`   Measuring response time consistency (${testResult.sampleSize} samples)...`);
        
        // Use same endpoint for consistency
        const endpoint = '/nfl/chiefs/logo';
        
        for (let i = 0; i < testResult.sampleSize; i++) {
            const response = await makeRequest(`${BASE_URL}${endpoint}`);
            
            if (response.statusCode === 200) {
                responseTimes.push(response.duration);
            }
            
            await sleep(50); // Small delay between requests
        }
        
        testResult.duration = Date.now() - startTime;
        testResult.responseTimes = responseTimes;
        testResult.avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
        
        // Calculate standard deviation
        const squareDiffs = responseTimes.map(time => Math.pow(time - testResult.avgResponseTime, 2));
        const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
        testResult.stdDeviation = Math.sqrt(avgSquareDiff);
        testResult.variability = (testResult.stdDeviation / testResult.avgResponseTime * 100).toFixed(2);
        
        // Pass if variability is less than 50%
        if (testResult.variability < 50) {
            testResult.passed = true;
        } else {
            throw new Error(`High variability: ${testResult.variability}% (stddev: ${testResult.stdDeviation.toFixed(2)}ms)`);
        }
    } catch (error) {
        testResult.error = error.message;
        testResult.duration = Date.now() - startTime;
    }

    return testResult;
}

async function testMemoryLeaks() {
    const testResult = {
        name: 'Memory Leak Detection (Sustained Load)',
        passed: false,
        error: null,
        duration: 0,
        requestCount: 100,
        successCount: 0,
        failureCount: 0
    };

    const startTime = Date.now();

    try {
        console.log(`   Running sustained load test (${testResult.requestCount} requests)...`);
        
        // Make many requests over time to check for memory leaks or degradation
        for (let i = 0; i < testResult.requestCount; i++) {
            const endpoint = TEST_ENDPOINTS[i % TEST_ENDPOINTS.length];
            
            try {
                const response = await makeRequest(`${BASE_URL}${endpoint}`);
                
                if (response.statusCode === 200) {
                    testResult.successCount++;
                } else {
                    testResult.failureCount++;
                }
            } catch (error) {
                testResult.failureCount++;
            }
            
            if ((i + 1) % 20 === 0) {
                process.stdout.write(`\r   Progress: ${i + 1}/${testResult.requestCount}`);
            }
            
            // Small delay to simulate sustained load
            await sleep(20);
        }
        
        console.log(''); // New line after progress
        
        testResult.duration = Date.now() - startTime;
        
        // Pass if we maintained high success rate throughout
        if (testResult.successCount >= testResult.requestCount * 0.95) {
            testResult.passed = true;
        } else {
            throw new Error(`Success rate degraded: ${testResult.successCount}/${testResult.requestCount}`);
        }
    } catch (error) {
        testResult.error = error.message;
        testResult.duration = Date.now() - startTime;
    }

    return testResult;
}

// ------------------------------------------------------------------------------
// Main Test Execution
// ------------------------------------------------------------------------------

async function runAllTests() {
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('  PERFORMANCE TESTS');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    console.log('\nâ³ Waiting for server to be ready...');
    await waitForServer();
    console.log('âœ… Server is ready!\n');

    results.totalTests = Object.keys(PERF_CONFIGS).length + 2; // +2 for consistency and memory tests
    
    console.log(`ðŸ“Š Test Plan:`);
    console.log(`   - ${Object.keys(PERF_CONFIGS).length} load test configurations`);
    console.log(`   - 1 response time consistency test`);
    console.log(`   - 1 memory leak detection test`);
    console.log(`   - Total: ${results.totalTests} tests\n`);

    let testNumber = 0;
    const allResponseTimes = [];

    // Test 1-4: Load tests with increasing concurrency
    console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('  Testing Load Performance');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    for (const [key, config] of Object.entries(PERF_CONFIGS)) {
        testNumber++;
        console.log(`\n[${testNumber}/${results.totalTests}] ${config.name}`);
        
        let result;
        if (config.concurrent === 1) {
            result = await testSequentialRequests(config);
        } else {
            result = await testConcurrentRequests(config);
        }
        
        results.tests.push(result);
        allResponseTimes.push(...result.responseTimes);
        
        if (result.passed) {
            results.passed++;
            console.log(`   âœ… PASSED (${result.duration}ms total)`);
            console.log(`      Success: ${result.successCount}/${result.requestCount}`);
            console.log(`      Avg Response Time: ${result.avgResponseTime}ms`);
            console.log(`      Throughput: ${result.throughput} req/s`);
        } else {
            results.failed++;
            console.log(`   âŒ FAILED: ${result.error} (${result.duration}ms)`);
        }
        
        // Wait between load tests
        await sleep(1000);
    }

    // Test 5: Response Time Consistency
    console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('  Testing Response Time Consistency');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    testNumber++;
    console.log(`\n[${testNumber}/${results.totalTests}] Response Time Consistency`);
    
    const consistencyResult = await testResponseTimeConsistency();
    results.tests.push(consistencyResult);
    allResponseTimes.push(...consistencyResult.responseTimes);
    
    if (consistencyResult.passed) {
        results.passed++;
        console.log(`   âœ… PASSED (${consistencyResult.duration}ms)`);
        console.log(`      Avg: ${consistencyResult.avgResponseTime.toFixed(2)}ms`);
        console.log(`      Std Dev: ${consistencyResult.stdDeviation.toFixed(2)}ms`);
        console.log(`      Variability: ${consistencyResult.variability}%`);
    } else {
        results.failed++;
        console.log(`   âŒ FAILED: ${consistencyResult.error}`);
    }
    
    await sleep(1000);

    // Test 6: Memory Leak Detection
    console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('  Testing for Memory Leaks');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    testNumber++;
    console.log(`\n[${testNumber}/${results.totalTests}] Memory Leak Detection`);
    
    const memoryResult = await testMemoryLeaks();
    results.tests.push(memoryResult);
    
    if (memoryResult.passed) {
        results.passed++;
        console.log(`   âœ… PASSED (${memoryResult.duration}ms)`);
        console.log(`      Success Rate: ${memoryResult.successCount}/${memoryResult.requestCount}`);
    } else {
        results.failed++;
        console.log(`   âŒ FAILED: ${memoryResult.error}`);
    }

    // Calculate overall performance metrics
    updatePerformanceMetrics(allResponseTimes);

    // Print summary
    printSummary();

    // Exit with appropriate code
    process.exit(results.failed > 0 ? 1 : 0);
}

// ------------------------------------------------------------------------------
// Summary
// ------------------------------------------------------------------------------

function printSummary() {
    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('  TEST SUMMARY');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`  Total Tests:  ${results.totalTests}`);
    console.log(`  âœ… Passed:     ${results.passed}`);
    console.log(`  âŒ Failed:     ${results.failed}`);
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    console.log('ðŸ“ˆ Performance Metrics (All Tests):');
    console.log(`   Average Response Time:  ${results.performanceMetrics.averageResponseTime}ms`);
    console.log(`   Median Response Time:   ${results.performanceMetrics.medianResponseTime}ms`);
    console.log(`   P95 Response Time:      ${results.performanceMetrics.p95ResponseTime}ms`);
    console.log(`   P99 Response Time:      ${results.performanceMetrics.p99ResponseTime}ms`);
    console.log(`   Min Response Time:      ${results.performanceMetrics.minResponseTime}ms`);
    console.log(`   Max Response Time:      ${results.performanceMetrics.maxResponseTime}ms`);
    console.log('');

    if (results.failed > 0) {
        console.log('Failed Tests:');
        results.tests.filter(t => !t.passed).forEach(test => {
            console.log(`  âŒ ${test.name}`);
            console.log(`     Error: ${test.error}`);
        });
        console.log('');
    }

    saveResults();
}

// ------------------------------------------------------------------------------
// Start Server and Run Tests
// ------------------------------------------------------------------------------

if (require.main === module) {
    process.env.PORT = PORT;
    process.env.NODE_ENV = 'development';
    process.env.TRUST_PROXY = '0';
    process.env.RATE_LIMIT_PER_MINUTE = '0';
    process.env.IMAGE_CACHE_HOURS = '0';
    process.env.LOG_TO_FILE = 'false';
    process.env.SHOW_TIMESTAMP = 'false';
    process.env.XC_PROXY = 'false';
    
    require('../index');
    
    setTimeout(() => {
        runAllTests().catch(error => {
            console.error('\nðŸ’¥ Test suite failed:', error);
            process.exit(1);
        });
    }, 2000);
}

// ------------------------------------------------------------------------------

name: Generate Changelog

on:
  push:
    branches:
      - main
      - changelog-test
  release:
    types: [published]

permissions:
  contents: write
  pull-requests: write

jobs:
  generate-changelog:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Get version and tag information
        id: version_info
        run: |
          # Get all version tags (semantic versioning)
          TAGS=$(git tag -l 'v*' --sort=-v:refname)
          LAST_TAG=$(echo "$TAGS" | head -n 1)
          
          # Check if working directory is clean
          if git diff-index --quiet HEAD --; then
            IS_DIRTY="false"
          else
            IS_DIRTY="true"
          fi
          
          # Get current branch
          BRANCH="${{ github.ref_name }}"
          
          # Determine current version status
          if [ -n "$LAST_TAG" ]; then
            CURRENT_VERSION="$LAST_TAG"
            if [ "$IS_DIRTY" = "true" ]; then
              CURRENT_VERSION="${LAST_TAG}-dirty"
            fi
          else
            CURRENT_VERSION="unversioned"
          fi
          
          # Determine if this is a release event
          if [ "${{ github.event_name }}" = "release" ]; then
            LAST_TAG=$(echo "$TAGS" | sed -n '2p')  # Get second most recent tag
          fi
          
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "is_dirty=$IS_DIRTY" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "all_tags<<EOF" >> $GITHUB_OUTPUT
          echo "$TAGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Get commits with diffs
        id: commits
        run: |
          # Check if CHANGELOG.md exists to determine if we need full history
          CHANGELOG_EXISTS="false"
          if [ -f "CHANGELOG.md" ]; then
            CHANGELOG_EXISTS="true"
          fi
          
          LAST_TAG="${{ steps.version_info.outputs.last_tag }}"
          
          if [ "$CHANGELOG_EXISTS" = "false" ]; then
            # No changelog exists - get ALL commits for backfill from all branches
            echo "No CHANGELOG.md found - collecting full history for backfill"
            COMMITS=$(git log --all --pretty=format:"%h|%s|%an|%ae|%D")
          elif [ -z "$LAST_TAG" ]; then
            # Changelog exists but no tags - get recent commits from all branches
            COMMITS=$(git log --all --pretty=format:"%h|%s|%an|%ae|%D" -20)
          else
            # Normal update - get commits since last tag
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%h|%s|%an|%ae|%D")
          fi
          
          # Save commits to file
          echo "$COMMITS" > commits.txt
          
          # Get diffs for each commit with stat summary (reduced for token limits)
          echo "Collecting diffs for commits..."
          > commits_with_diffs.txt
          COMMIT_COUNT=0
          while IFS='|' read -r hash subject author email refs; do
            if [ -n "$hash" ]; then
              COMMIT_COUNT=$((COMMIT_COUNT + 1))
              # Include refs as 4th field for proper parsing
              echo "=== COMMIT: $hash | $subject | $author | $refs ===" >> commits_with_diffs.txt
              
              # Get diff stat
              git show --stat --format="" "$hash" >> commits_with_diffs.txt 2>/dev/null || echo "No diff available" >> commits_with_diffs.txt
              
              # Include diffs for better context (limit per commit, but include more commits)
              # Recent commits get full diffs, older get smaller samples
              if [ $COMMIT_COUNT -le 30 ]; then
                echo "Changes:" >> commits_with_diffs.txt
                git show --format="" "$hash" -- . ':(exclude)package-lock.json' ':(exclude)yarn.lock' ':(exclude)*.lock' | head -n 300 >> commits_with_diffs.txt 2>/dev/null
              elif [ $COMMIT_COUNT -le 50 ]; then
                echo "Key changes:" >> commits_with_diffs.txt
                git show --format="" "$hash" -- . ':(exclude)package-lock.json' ':(exclude)yarn.lock' ':(exclude)*.lock' | head -n 100 >> commits_with_diffs.txt 2>/dev/null
              fi
              
              echo "" >> commits_with_diffs.txt
            fi
          done < commits.txt
          
          echo "Processed $COMMIT_COUNT commits"
          
          echo "changelog_exists=$CHANGELOG_EXISTS" >> $GITHUB_OUTPUT
          echo "commits_file=commits.txt" >> $GITHUB_OUTPUT
      
      - name: Generate changelog with AI
        id: generate
        env:
          GITHUB_TOKEN: ${{ secrets.MODELS_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Read existing CHANGELOG.md if it exists
          EXISTING_CHANGELOG=""
          if [ -f "CHANGELOG.md" ]; then
            EXISTING_CHANGELOG=$(cat CHANGELOG.md)
            
            # Extract already processed commit hashes from metadata comments
            echo "Extracting processed commits from existing changelog..."
            PROCESSED_HASHES=$(grep -oP '<!-- Processed commits: \K[^>]+' CHANGELOG.md | tr ',' '\n' | sort -u)
            
            if [ -n "$PROCESSED_HASHES" ]; then
              echo "Found $(echo "$PROCESSED_HASHES" | wc -l) already-processed commits"
              
              # Filter out already-processed commits
              > commits_filtered.txt
              while IFS='|' read -r hash subject author email refs; do
                if [ -n "$hash" ] && ! echo "$PROCESSED_HASHES" | grep -q "^${hash}$"; then
                  echo "$hash|$subject|$author|$email|$refs" >> commits_filtered.txt
                fi
              done < commits.txt
              
              # Check if there are new commits to process
              NEW_COUNT=$(wc -l < commits_filtered.txt | tr -d ' ')
              TOTAL_COUNT=$(wc -l < commits.txt | tr -d ' ')
              echo "Filtered: $NEW_COUNT new commits out of $TOTAL_COUNT total"
              
              if [ "$NEW_COUNT" -eq 0 ]; then
                echo "No new commits to process - changelog is up to date"
                echo "changelog_generated=false" >> $GITHUB_OUTPUT
                exit 0
              fi
              
              # Use filtered commits
              mv commits_filtered.txt commits.txt
            fi
          fi
          
          # Read commits
          COMMITS=$(cat commits.txt)
          
          # Get version and tag info
          VERSION="${{ steps.version_info.outputs.current_version }}"
          LAST_TAG="${{ steps.version_info.outputs.last_tag }}"
          ALL_TAGS="${{ steps.version_info.outputs.all_tags }}"
          IS_DIRTY="${{ steps.version_info.outputs.is_dirty }}"
          BRANCH="${{ steps.version_info.outputs.branch }}"
          CHANGELOG_EXISTS="${{ steps.commits.outputs.changelog_exists }}"
          
          # Read commits with diffs
          COMMITS_WITH_DIFFS=$(cat commits_with_diffs.txt)
          
          # Get commit dates for each tag to help with backfill
          TAG_DATES=""
          if [ "$CHANGELOG_EXISTS" = "false" ] && [ -n "$ALL_TAGS" ]; then
            echo "Collecting tag dates for version history..."
            while IFS= read -r tag; do
              if [ -n "$tag" ]; then
                TAG_DATE=$(git log -1 --format=%ai "$tag" 2>/dev/null | cut -d' ' -f1)
                TAG_DATES="${TAG_DATES}${tag}: ${TAG_DATE}"$'\n'
              fi
            done <<< "$ALL_TAGS"
          fi
          
          # Export variables for Python scripts
          export VERSION="$VERSION"
          export LAST_TAG="$LAST_TAG"
          export BRANCH="$BRANCH"
          export IS_DIRTY="$IS_DIRTY"
          export DATE="$(date +%Y-%m-%d)"
          export TAG_DATES="$TAG_DATES"
          export ALL_TAGS="$ALL_TAGS"
          export GITHUB_TOKEN="$GITHUB_TOKEN"
          
          # Always use chunked processing for consistency
          echo "Using chunked processing for changelog generation..."
          PYTHONUNBUFFERED=1 python3 .github/workflows/scripts/process-changelog-chunked.py
          
          if [ $? -eq 0 ]; then
            echo "changelog_generated=true" >> $GITHUB_OUTPUT
          else
            echo "error=true" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Output changelog to summary
        if: steps.generate.outputs.changelog_generated == 'true'
        run: |
          echo "## üìù Generated Changelog" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.version_info.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Changes since:** ${{ steps.version_info.outputs.last_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat CHANGELOG.md >> $GITHUB_STEP_SUMMARY
      
      - name: Clean up temporary files
        if: steps.generate.outputs.changelog_generated == 'true'
        run: |
          # Remove all temporary files generated during processing
          rm -f commits.txt commits_with_diffs.txt request.json api_response.json prompt.txt api_request_temp.json
          echo "Cleaned up temporary files"
      
      - name: Check for changes
        id: check_changes
        if: steps.generate.outputs.changelog_generated == 'true'
        run: |
          # Check if CHANGELOG.md is new (untracked) or modified
          if git ls-files --error-unmatch CHANGELOG.md > /dev/null 2>&1; then
            # File exists in git, check for changes
            if git diff --quiet CHANGELOG.md && git diff --cached --quiet CHANGELOG.md; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "No changes detected in CHANGELOG.md"
            else
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "Changes detected in CHANGELOG.md"
            fi
          else
            # File is new (not tracked by git)
            if [ -f CHANGELOG.md ]; then
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "CHANGELOG.md is new (not yet tracked)"
            else
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "CHANGELOG.md does not exist"
            fi
          fi
      
      - name: Create Pull Request
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "docs: update CHANGELOG.md"
          title: "Changelog Update #${{ github.run_number }}"
          body: |
            ## üìù Automated Changelog Update
            
            This PR updates the CHANGELOG.md file with recent changes following the [Keep a Changelog](https://keepachangelog.com/) format.
            
            **Version Information:**
            - Current version: `${{ steps.version_info.outputs.current_version }}`
            - Changes since: `${{ steps.version_info.outputs.last_tag }}`
            - Source branch: `${{ github.ref_name }}`
            
            **Processing Details:**
            - Total commits analyzed: Extracted from git history
            - AI-powered analysis using GitHub Models (gpt-4o-mini)
            - Automatic deduplication and consolidation of similar entries
            
            **Semantic Versioning:**
            This project follows [Semantic Versioning](https://semver.org/spec/v2.0.0.html) (MAJOR.MINOR.PATCH)
            
            ---
            
            Generated by GitHub Actions ‚Ä¢ Please review and merge if correct
          branch: changelog/${{ github.run_number }}
          base: main
          delete-branch: true

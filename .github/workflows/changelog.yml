name: Generate Changelog

on:
  push:
    branches:
      - main
      - changelog-test
  release:
    types: [published]

permissions:
  contents: write
  pull-requests: write

jobs:
  generate-changelog:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Get version and tag information
        id: version_info
        run: |
          # Get all version tags (semantic versioning)
          TAGS=$(git tag -l 'v*' --sort=-v:refname)
          LAST_TAG=$(echo "$TAGS" | head -n 1)
          
          # Check if working directory is clean
          if git diff-index --quiet HEAD --; then
            IS_DIRTY="false"
          else
            IS_DIRTY="true"
          fi
          
          # Get current branch
          BRANCH="${{ github.ref_name }}"
          
          # Determine current version status
          if [ -n "$LAST_TAG" ]; then
            CURRENT_VERSION="$LAST_TAG"
            if [ "$IS_DIRTY" = "true" ]; then
              CURRENT_VERSION="${LAST_TAG}-dirty"
            fi
          else
            CURRENT_VERSION="unversioned"
          fi
          
          # Determine if this is a release event
          if [ "${{ github.event_name }}" = "release" ]; then
            LAST_TAG=$(echo "$TAGS" | sed -n '2p')  # Get second most recent tag
          fi
          
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "is_dirty=$IS_DIRTY" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "all_tags<<EOF" >> $GITHUB_OUTPUT
          echo "$TAGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Get commits with diffs
        id: commits
        run: |
          # Check if CHANGELOG.md exists to determine if we need full history
          CHANGELOG_EXISTS="false"
          if [ -f "CHANGELOG.md" ]; then
            CHANGELOG_EXISTS="true"
          fi
          
          LAST_TAG="${{ steps.version_info.outputs.last_tag }}"
          
          if [ "$CHANGELOG_EXISTS" = "false" ]; then
            # No changelog exists - get ALL commits for backfill from all branches
            echo "No CHANGELOG.md found - collecting full history for backfill"
            COMMITS=$(git log --all --pretty=format:"%h|%s|%an|%ae|%D")
          elif [ -z "$LAST_TAG" ]; then
            # Changelog exists but no tags - get recent commits from all branches
            COMMITS=$(git log --all --pretty=format:"%h|%s|%an|%ae|%D" -20)
          else
            # Normal update - get commits since last tag
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"%h|%s|%an|%ae|%D")
          fi
          
          # Save commits to file
          echo "$COMMITS" > commits.txt
          
          # Get diffs for each commit with stat summary (reduced for token limits)
          echo "Collecting diffs for commits..."
          > commits_with_diffs.txt
          COMMIT_COUNT=0
          while IFS='|' read -r hash subject author email refs; do
            if [ -n "$hash" ]; then
              COMMIT_COUNT=$((COMMIT_COUNT + 1))
              # Include refs as 4th field for proper parsing
              echo "=== COMMIT: $hash | $subject | $author | $refs ===" >> commits_with_diffs.txt
              
              # Get diff stat
              git show --stat --format="" "$hash" >> commits_with_diffs.txt 2>/dev/null || echo "No diff available" >> commits_with_diffs.txt
              
              # Include diffs for better context (limit per commit, but include more commits)
              # Recent commits get full diffs, older get smaller samples
              if [ $COMMIT_COUNT -le 30 ]; then
                echo "Changes:" >> commits_with_diffs.txt
                git show --format="" "$hash" -- . ':(exclude)package-lock.json' ':(exclude)yarn.lock' ':(exclude)*.lock' | head -n 300 >> commits_with_diffs.txt 2>/dev/null
              elif [ $COMMIT_COUNT -le 50 ]; then
                echo "Key changes:" >> commits_with_diffs.txt
                git show --format="" "$hash" -- . ':(exclude)package-lock.json' ':(exclude)yarn.lock' ':(exclude)*.lock' | head -n 100 >> commits_with_diffs.txt 2>/dev/null
              fi
              
              echo "" >> commits_with_diffs.txt
            fi
          done < commits.txt
          
          echo "Processed $COMMIT_COUNT commits"
          
          echo "changelog_exists=$CHANGELOG_EXISTS" >> $GITHUB_OUTPUT
          echo "commits_file=commits.txt" >> $GITHUB_OUTPUT
      
      - name: Generate changelog with AI
        id: generate
        env:
          GITHUB_TOKEN: ${{ secrets.MODELS_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          # Read existing CHANGELOG.md if it exists
          EXISTING_CHANGELOG=""
          if [ -f "CHANGELOG.md" ]; then
            EXISTING_CHANGELOG=$(cat CHANGELOG.md)
          fi
          
          # Read commits
          COMMITS=$(cat commits.txt)
          
          # Get version and tag info
          VERSION="${{ steps.version_info.outputs.current_version }}"
          LAST_TAG="${{ steps.version_info.outputs.last_tag }}"
          ALL_TAGS="${{ steps.version_info.outputs.all_tags }}"
          IS_DIRTY="${{ steps.version_info.outputs.is_dirty }}"
          BRANCH="${{ steps.version_info.outputs.branch }}"
          CHANGELOG_EXISTS="${{ steps.commits.outputs.changelog_exists }}"
          
          # Read commits with diffs
          COMMITS_WITH_DIFFS=$(cat commits_with_diffs.txt)
          
          # Get commit dates for each tag to help with backfill
          TAG_DATES=""
          if [ "$CHANGELOG_EXISTS" = "false" ] && [ -n "$ALL_TAGS" ]; then
            echo "Collecting tag dates for version history..."
            while IFS= read -r tag; do
              if [ -n "$tag" ]; then
                TAG_DATE=$(git log -1 --format=%ai "$tag" 2>/dev/null | cut -d' ' -f1)
                TAG_DATES="${TAG_DATES}${tag}: ${TAG_DATE}"$'\n'
              fi
            done <<< "$ALL_TAGS"
          fi
          
          # Export variables for Python scripts
          export VERSION="$VERSION"
          export LAST_TAG="$LAST_TAG"
          export BRANCH="$BRANCH"
          export IS_DIRTY="$IS_DIRTY"
          export DATE="$(date +%Y-%m-%d)"
          export TAG_DATES="$TAG_DATES"
          export ALL_TAGS="$ALL_TAGS"
          export GITHUB_TOKEN="$GITHUB_TOKEN"
          
          USE_CHUNKED="false"
          
          # Try to generate request first to check size
          if [ "$CHANGELOG_EXISTS" = "false" ]; then
            python3 .github/workflows/scripts/generate-backfill-prompt.py
          else
            python3 .github/workflows/scripts/generate-update-prompt.py
          fi
          
          # Check request size and decide on approach
          if [ -f request.json ]; then
            REQUEST_SIZE=$(wc -c < request.json)
            # Rough estimate: 1 byte ‚âà 0.25 tokens, so 30KB ‚âà 7500 tokens
            echo "Request body size: $REQUEST_SIZE bytes"
            
            if [ $REQUEST_SIZE -gt 30000 ]; then
              echo "‚ö†Ô∏è  Request too large ($REQUEST_SIZE bytes), switching to chunked processing..."
              USE_CHUNKED="true"
            fi
          fi
          
          # Process based on size
          if [ "$USE_CHUNKED" = "true" ]; then
            echo "Using chunked processing for large changelog..."
            PYTHONUNBUFFERED=1 python3 .github/workflows/scripts/process-changelog-chunked.py
            
            if [ $? -eq 0 ]; then
              echo "changelog_generated=true" >> $GITHUB_OUTPUT
            else
              echo "error=true" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            # Use single API call for smaller requests
            echo "Using single API call for changelog generation..."

            # Call GitHub Models API with gpt-4o-mini
            echo "Calling GitHub Models API..."
            RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X POST \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              https://models.inference.ai.azure.com/chat/completions \
              --data-binary @request.json)
            
            # Extract HTTP code and response body
            HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d':' -f2)
            RESPONSE_BODY=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')
            
            echo "HTTP Status Code: $HTTP_CODE"
            
            # Check for errors
            if [ "$HTTP_CODE" != "200" ]; then
              echo "API Error (HTTP $HTTP_CODE):"
              echo "$RESPONSE_BODY" | jq '.' || echo "$RESPONSE_BODY"
              echo "error=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Save full response for debugging
            echo "$RESPONSE_BODY" > api_response.json
            
            # Check if response has error
            ERROR_MSG=$(echo "$RESPONSE_BODY" | jq -r '.error.message // empty')
            if [ -n "$ERROR_MSG" ]; then
              echo "API returned error: $ERROR_MSG"
              echo "error=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Format the changelog using Python for consistent output
            echo "Formatting changelog with Python..."
            export CHANGELOG_EXISTS="$CHANGELOG_EXISTS"
            python3 .github/workflows/scripts/format-changelog.py
            
            if [ $? -eq 0 ]; then
              echo "Changelog formatted successfully!"
              echo "changelog_generated=true" >> $GITHUB_OUTPUT
            else
              echo "error=true" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi
      
      - name: Output changelog to summary
        if: steps.generate.outputs.changelog_generated == 'true'
        run: |
          echo "## üìù Generated Changelog" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.version_info.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Changes since:** ${{ steps.version_info.outputs.last_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat CHANGELOG.md >> $GITHUB_STEP_SUMMARY
      
      - name: Check for changes
        id: check_changes
        if: steps.generate.outputs.changelog_generated == 'true'
        run: |
          # Check if CHANGELOG.md is new (untracked) or modified
          if git ls-files --error-unmatch CHANGELOG.md > /dev/null 2>&1; then
            # File exists in git, check for changes
            if git diff --quiet CHANGELOG.md && git diff --cached --quiet CHANGELOG.md; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "No changes detected in CHANGELOG.md"
            else
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "Changes detected in CHANGELOG.md"
            fi
          else
            # File is new (not tracked by git)
            if [ -f CHANGELOG.md ]; then
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "CHANGELOG.md is new (not yet tracked)"
            else
              echo "has_changes=false" >> $GITHUB_OUTPUT
              echo "CHANGELOG.md does not exist"
            fi
          fi
      
      - name: Create Pull Request
        if: steps.check_changes.outputs.has_changes == 'true'
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "docs: update CHANGELOG.md"
          title: "chore: Update Changelog for ${{ steps.version_info.outputs.current_version }}"
          body: |
            ## üìù Automated Changelog Update
            
            This PR updates the CHANGELOG.md file with recent changes following the [Keep a Changelog](https://keepachangelog.com/) format.
            
            **Version Information:**
            - Current version: `${{ steps.version_info.outputs.current_version }}`
            - Changes since: `${{ steps.version_info.outputs.last_tag }}`
            - Branch: `${{ github.ref_name }}`
            
            **Processing Details:**
            - Total commits analyzed: Extracted from git history
            - AI-powered analysis using GitHub Models (gpt-4o-mini)
            - Automatic deduplication and consolidation of similar entries
            
            **Semantic Versioning:**
            This project follows [Semantic Versioning](https://semver.org/spec/v2.0.0.html) (MAJOR.MINOR.PATCH)
            
            ---
            
            Generated by GitHub Actions ‚Ä¢ Please review and merge if correct
          branch: changelog-update-${{ github.run_number }}
          base: ${{ github.ref_name }}
          delete-branch: true
